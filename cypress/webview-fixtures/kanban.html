<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="/vscode-theme.css" rel="stylesheet" />
    <title>Kanban Board Test</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: var(--vscode-font-family, -apple-system, BlinkMacSystemFont, sans-serif);
        font-size: 13px;
        background: var(--vscode-editor-background, #1e1e1e);
        color: var(--vscode-editor-foreground, #cccccc);
      }
      .kanban-board {
        display: flex;
        gap: 12px;
        padding: 12px;
        min-height: calc(100vh - 24px);
      }
      .kanban-column {
        flex: 1;
        min-width: 200px;
        max-width: 300px;
        background: var(--vscode-sideBar-background, #252526);
        border-radius: 8px;
        padding: 12px;
        display: flex;
        flex-direction: column;
      }
      .column-header {
        font-weight: 600;
        font-size: 12px;
        text-transform: uppercase;
        color: var(--vscode-descriptionForeground, #858585);
        margin-bottom: 12px;
        display: flex;
        justify-content: space-between;
      }
      .column-count {
        background: var(--vscode-badge-background, #4d4d4d);
        color: var(--vscode-badge-foreground, #ffffff);
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 11px;
      }
      .task-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 50px;
        flex: 1;
      }
      .task-list.drop-target {
        background: rgba(0, 122, 204, 0.1);
        border-radius: 4px;
      }
      .task-card {
        background: var(--vscode-editor-background, #1e1e1e);
        border: 1px solid var(--vscode-widget-border, #454545);
        border-radius: 6px;
        padding: 10px;
        cursor: grab;
        transition: all 0.15s ease;
      }
      .task-card:hover {
        border-color: var(--vscode-focusBorder, #007acc);
      }
      .task-card.dragging {
        opacity: 0.6;
        cursor: grabbing;
        transform: rotate(2deg) scale(1.05);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      }
      .task-card.saving {
        opacity: 0.7;
        pointer-events: none;
      }
      .task-card-title {
        font-size: 13px;
        font-weight: 500;
      }
      .task-card-meta {
        margin-top: 6px;
        font-size: 10px;
        color: var(--vscode-descriptionForeground, #858585);
      }
      .drop-indicator {
        height: 3px;
        background: var(--vscode-focusBorder, #007acc);
        border-radius: 2px;
        margin: 4px 0;
      }
    </style>
  </head>
  <body>
    <div class="kanban-board">
      <div class="kanban-column" data-status="To Do">
        <div class="column-header">
          <span>To Do</span>
          <span class="column-count" data-cy="todo-count">3</span>
        </div>
        <div class="task-list" data-status="To Do" data-cy="todo-list">
          <!-- Task with ordinal -->
          <div
            class="task-card"
            draggable="true"
            data-task-id="TASK-1"
            data-ordinal="1000"
            data-cy="task-1"
          >
            <div class="task-card-title">Task 1 (ordinal: 1000)</div>
            <div class="task-card-meta">Has ordinal</div>
          </div>
          <!-- Task without ordinal -->
          <div
            class="task-card"
            draggable="true"
            data-task-id="TASK-2"
            data-ordinal=""
            data-cy="task-2"
          >
            <div class="task-card-title">Task 2 (no ordinal)</div>
            <div class="task-card-meta">No ordinal</div>
          </div>
          <!-- Task without ordinal -->
          <div
            class="task-card"
            draggable="true"
            data-task-id="TASK-3"
            data-ordinal=""
            data-cy="task-3"
          >
            <div class="task-card-title">Task 3 (no ordinal)</div>
            <div class="task-card-meta">No ordinal</div>
          </div>
        </div>
      </div>
      <div class="kanban-column" data-status="In Progress">
        <div class="column-header">
          <span>In Progress</span>
          <span class="column-count" data-cy="progress-count">2</span>
        </div>
        <div class="task-list" data-status="In Progress" data-cy="progress-list">
          <!-- Task with ordinal -->
          <div
            class="task-card"
            draggable="true"
            data-task-id="TASK-4"
            data-ordinal="500"
            data-cy="task-4"
          >
            <div class="task-card-title">Task 4 (ordinal: 500)</div>
            <div class="task-card-meta">Has ordinal</div>
          </div>
          <!-- Task with ordinal -->
          <div
            class="task-card"
            draggable="true"
            data-task-id="TASK-5"
            data-ordinal="1500"
            data-cy="task-5"
          >
            <div class="task-card-title">Task 5 (ordinal: 1500)</div>
            <div class="task-card-meta">Has ordinal</div>
          </div>
        </div>
      </div>
      <div class="kanban-column" data-status="Done">
        <div class="column-header">
          <span>Done</span>
          <span class="column-count" data-cy="done-count">2</span>
        </div>
        <div class="task-list" data-status="Done" data-cy="done-list">
          <!-- Task without ordinal -->
          <div
            class="task-card"
            draggable="true"
            data-task-id="TASK-6"
            data-ordinal=""
            data-cy="task-6"
          >
            <div class="task-card-title">Task 6 (no ordinal)</div>
            <div class="task-card-meta">No ordinal</div>
          </div>
          <!-- Task without ordinal -->
          <div
            class="task-card"
            draggable="true"
            data-task-id="TASK-7"
            data-ordinal=""
            data-cy="task-7"
          >
            <div class="task-card-title">Task 7 (no ordinal)</div>
            <div class="task-card-meta">No ordinal</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const vscode = acquireVsCodeApi();

      // Helper to check if a card has an ordinal
      function hasOrdinal(card) {
        return card.dataset.ordinal !== '' && card.dataset.ordinal !== undefined;
      }

      // Calculate ordinals for a drop operation
      function calculateOrdinalsForDrop(list, draggedCard, dropTarget) {
        const DEFAULT_STEP = 1000;
        const updates = [];

        // Get all cards except the dragged one, in current visual order
        const otherCards = [...list.querySelectorAll('.task-card')].filter(
          (c) => c !== draggedCard
        );

        // Determine the drop index
        let dropIndex = dropTarget ? otherCards.indexOf(dropTarget) : otherCards.length;

        // Build the new visual order with the dropped card inserted
        const newOrder = [...otherCards];
        newOrder.splice(dropIndex, 0, draggedCard);

        // Find all no-ordinal cards at or above the drop position
        const cardsNeedingOrdinals = [];
        for (let i = 0; i <= dropIndex; i++) {
          const c = newOrder[i];
          const cardHasOrdinal = c.dataset.ordinal !== '' && c.dataset.ordinal !== undefined;
          if (!cardHasOrdinal || c === draggedCard) {
            cardsNeedingOrdinals.push({ card: c, index: i });
          }
        }

        // Calculate ordinals
        if (cardsNeedingOrdinals.length > 0) {
          const firstNeedingIndex = cardsNeedingOrdinals[0].index;

          let baseOrdinal = 0;
          if (firstNeedingIndex > 0) {
            const prevCard = newOrder[firstNeedingIndex - 1];
            if (prevCard.dataset.ordinal !== '' && prevCard.dataset.ordinal !== undefined) {
              baseOrdinal = parseFloat(prevCard.dataset.ordinal) || 0;
            }
          }

          let ceilingOrdinal = Infinity;
          for (let i = dropIndex + 1; i < newOrder.length; i++) {
            const c = newOrder[i];
            if (c.dataset.ordinal !== '' && c.dataset.ordinal !== undefined) {
              ceilingOrdinal = parseFloat(c.dataset.ordinal);
              break;
            }
          }

          const count = cardsNeedingOrdinals.length;
          let step = DEFAULT_STEP;
          if (ceilingOrdinal !== Infinity) {
            const availableRange = ceilingOrdinal - baseOrdinal;
            step = Math.min(DEFAULT_STEP, availableRange / (count + 1));
          }

          cardsNeedingOrdinals.forEach((item, i) => {
            const newOrdinal = baseOrdinal + step * (i + 1);
            updates.push({
              taskId: item.card.dataset.taskId,
              ordinal: newOrdinal,
            });
          });
        }

        return updates;
      }

      function getDropTarget(e, list, draggedCard) {
        const cards = [...list.querySelectorAll('.task-card:not(.dragging)')].filter(
          (c) => c !== draggedCard
        );
        return (
          cards.find((card) => {
            const rect = card.getBoundingClientRect();
            return e.clientY < rect.top + rect.height / 2;
          }) || null
        );
      }

      function updateColumnCounts() {
        document.querySelectorAll('.kanban-column').forEach((col) => {
          const count = col.querySelectorAll('.task-card').length;
          const countEl = col.querySelector('.column-count');
          if (countEl) countEl.textContent = count;
        });
      }

      function clearDropIndicators() {
        document.querySelectorAll('.drop-indicator').forEach((el) => el.remove());
        document.querySelectorAll('.task-list').forEach((list) => {
          list.classList.remove('drop-target');
        });
      }

      function showDropIndicator(list, beforeElement) {
        clearDropIndicators();
        list.classList.add('drop-target');

        const indicator = document.createElement('div');
        indicator.className = 'drop-indicator';

        if (beforeElement) {
          list.insertBefore(indicator, beforeElement);
        } else {
          list.appendChild(indicator);
        }
      }

      // Setup drag and drop
      const cards = document.querySelectorAll('.task-card');
      const lists = document.querySelectorAll('.task-list');

      cards.forEach((card) => {
        card.addEventListener('dragstart', (e) => {
          setTimeout(() => card.classList.add('dragging'), 0);
          e.dataTransfer.setData('text/plain', card.dataset.taskId);
          e.dataTransfer.effectAllowed = 'move';
        });

        card.addEventListener('dragend', () => {
          card.classList.remove('dragging');
          clearDropIndicators();
        });
      });

      lists.forEach((list) => {
        list.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';

          const draggingCard = document.querySelector('.task-card.dragging');
          if (!draggingCard) return;

          const dropTarget = getDropTarget(e, list, draggingCard);
          showDropIndicator(list, dropTarget);
        });

        list.addEventListener('dragleave', (e) => {
          if (!list.contains(e.relatedTarget)) {
            clearDropIndicators();
          }
        });

        list.addEventListener('drop', (e) => {
          e.preventDefault();
          clearDropIndicators();

          const taskId = e.dataTransfer.getData('text/plain');
          const card = document.querySelector(`[data-task-id="${taskId}"]`);
          if (!card) return;

          const originalColumn = card.closest('.task-list');
          const originalStatus = originalColumn?.dataset.status;
          const newStatus = list.dataset.status;

          const dropTarget = getDropTarget(e, list, card);
          const ordinalUpdates = calculateOrdinalsForDrop(list, card, dropTarget);

          // Move card in DOM
          card.classList.add('saving');
          if (dropTarget) {
            list.insertBefore(card, dropTarget);
          } else {
            list.appendChild(card);
          }

          // Update data attributes
          ordinalUpdates.forEach((update) => {
            const c = document.querySelector(`[data-task-id="${update.taskId}"]`);
            if (c) c.dataset.ordinal = String(update.ordinal);
          });
          updateColumnCounts();

          if (originalStatus === newStatus) {
            // Same column reorder
            vscode.postMessage({
              type: 'reorderTasks',
              updates: ordinalUpdates,
            });
          } else {
            // Cross-column move
            const droppedCardUpdate = ordinalUpdates.find((u) => u.taskId === taskId);
            vscode.postMessage({
              type: 'updateTaskStatus',
              taskId: taskId,
              status: newStatus,
              ordinal: droppedCardUpdate?.ordinal,
              additionalOrdinalUpdates: ordinalUpdates.filter((u) => u.taskId !== taskId),
            });
          }

          // Remove saving state after a delay
          setTimeout(() => card.classList.remove('saving'), 100);
        });
      });
    </script>
  </body>
</html>
